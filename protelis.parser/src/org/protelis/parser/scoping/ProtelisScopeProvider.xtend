/*
 * generated by Xtext
 */
package org.protelis.parser.scoping

import java.util.ArrayList
import java.util.Collection
import java.util.List
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.common.types.JvmOperation
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.resource.EObjectDescription
import org.eclipse.xtext.resource.IEObjectDescription
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import org.eclipse.xtext.scoping.impl.MapBasedScope
import org.eclipse.xtext.scoping.impl.SimpleScope
import org.protelis.parser.protelis.Module

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation.html#scoping
 * on how and when to use it 
 *
 */
class ProtelisScopeProvider extends AbstractDeclarativeScopeProvider {
	
	def IScope scope_Expression_reference(Module model, EReference ref) {
		val List<EObject> internal = new ArrayList<EObject>(model.definitions)
		val List<IEObjectDescription> externalProtelis = new ArrayList<IEObjectDescription>()
		val List<IEObjectDescription> java = new ArrayList<IEObjectDescription>()
		model.protelisImport.forEach[ 
			val moduleName = it.module.name
			it.module.definitions.filter[public].forEach[
				externalProtelis.add(generateDescription(it.name, it))
				externalProtelis.add(generateDescription(moduleName + ":" + it.name, it))
			]
		]
		val javaImports = model.javaimports
		if(javaImports != null) {
			javaImports.importDeclarations.forEach[id |
				val type = id.importedType
				if(id.wildcard) {
					type.declaredOperations.filter[it.isStatic].populateMethodReferences(java)
				} else {
					val methodName = id.memberName
					type.declaredOperations.filter[it.isStatic]
						.filter[it.simpleName.equals(methodName)]
						.populateMethodReferences(java)
				}
			]
		}
		val plainProtelis = Scopes.scopeFor(internal)
		val refJava = new SimpleScope(java)
		/*
		 * Search locally => search Protelis imports => search Java imports
		 */
		val outer = MapBasedScope.createScope(refJava, externalProtelis)
		val final = MapBasedScope.createScope(outer, plainProtelis.allElements)
		final
	}
	
	def static populateMethodReferences(Iterable<JvmOperation> source, Collection<IEObjectDescription> destination) {
		source.forEach[
			destination.add(generateDescription(it.simpleName, it))
			destination.add(generateDescription(it.qualifiedName.replace(".", "::"), it))
		]
	}
	
	def static generateDescription(String name, EObject obj) {
		val ref = QualifiedName.create(name)
		EObjectDescription.create(ref, obj)
	}

}
